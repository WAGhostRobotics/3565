#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     sonar,          sensorSONAR)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     light,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     asf,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    jack1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    jack2,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Ultrasonic PID Wall Follow
Referenced resources here: http://www.societyofrobots.com/member_tutorials/book/export/html/350
1.0 - Starting stuff - Brandon Wang
*/
#include "Standard_Drive.c";
#include "nxtIO.c";



//TODO: look into using multiple sensors
void wallFollowDrive(float inches, int leftPow, int rightPow, float wallDistance)
{
		/*
		the correction is calculated by the formula:
		C = P + I + D
		P = error * kp
		I = I * ki (I = integral sum of all errors)
		D = D * kd (where D = the derivative of the error d/dt(e))
		*/

		//constants that vary the effect of the P, I, and D terms
		//TODO: tune values
		float kp = 2.0;//propotional constant
		float ki = 0.1;//integral constant
		float kd = 1;//derivative constant

		//declare variables used in PID
		int i = 0;//integral sum
		float p;//error used to calcualate PID correction
		int d;//derivative of error (p)
		int previousP = 0;//previous error used to calculate derivative
		int correction = 0;

		int encoderCounts = inchesToEncoder(inches);
		nMotorEncoder[left] = 0;

		while(nMotorEncoder[left] < encoderCounts)
		{
			int value = SensorValue[sonar];
			p = SensorValue[sonar] - wallDistance;
			i += p;
			d = p- previousP;//derivative disregards time (dt) as it should be time between loops should be constant - it will be compensated for in kd)
			correction = (int)round(kp*p + ki * i + kd*d);

			//if correction is positive, then p is positive, meaning it is father away from the wall then it should be
			//therefore a positive correciton should be added to the left motor power and subtracted from right motor power to turn the robot closer to the wall
			//this works for negative correction as well
			int newLeft = leftPow + correction;
			int newRight = rightPow - correction;

			if(newLeft < 20)
				newLeft = 20;
			if(newRight < 20)
				newRight =20;

		if(newLeft > 80)
				newLeft = 80;
			if(newRight > 80)
				newRight =80;



			motor[left] = (newLeft*1.3);
			motor[right] = newRight;

			print(newLeft,2);
			print(newRight,4);
			print(value, 6);

			print(p,8);
			wait10Msec(10);
			}
}

task main()

{
/*
while(true)
	{
		print(SensorValue[sonar], 4);
	}
*/



driveInches(16,30,20);
wait1Msec(500);
int sonarValue = SensorValue[sonar];
wait1Msec(500);
wallFollowDrive(84,30,30,sonarValue);
}
