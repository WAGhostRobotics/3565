#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     sonarFront,     sensorSONAR)
#pragma config(Sensor, S3,     sonarBack,      sensorSONAR)
#pragma config(Sensor, S4,     light,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     asf,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    jack1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    jack2,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Ultrasonic PID Wall Follow
Referenced resources here: http://www.societyofrobots.com/member_tutorials/book/export/html/350
1.0 - Starting stuff - Brandon Wang
1.1 - Changed to two sensors readings (renamed file)
*/
#include "Standard_Drive.c";
#include "nxtIO.c";



//Maintains the given distance from the wall, while also maintaining a parallel alignment along the wall
//Calculates PID correction on both alignment and distance by using relative distances from front and back sensors to calcualte alignment, and the avg distance reading
//from back and front sensor to calculate distance
void wallFollowDrive1(float inches, int leftPow, int rightPow, float wallDistance)
{
		/*
		the correction is calculated by the formula:
		C = P + I + D
		P = error * kp
		I = I * ki (I = integral sum of all errors)
		D = D * kd (where D = the derivative of the error d/dt(e))
		*/

		//constants that vary the effect of the P, I, and D terms
		//TODO: tune values
		float kp = 2.0;//propotional constant
		float ki = 0.1;//integral constant
		float kd = 1;//derivative constant

		//declare variables used in PID
		int i = 0;//integral sum
		float p=0;//error used to calcualate PID correction
		int d;//derivative of error (p)

		//used for avg distance
		float avgDistkp = 2.0;//propotional constant
		float avgDistki = 0.1;//integral constant
		float avgDistkd = 1;//derivative constant
		int avgDistI = 0;
		float avgDistP=0;
		int avgDistD;
		int previousAvgDistP = 0;

		int previousP = 0;//previous error used to calculate derivative
		int correction = 0;

		int encoderCounts = inchesToEncoder(inches);
		nMotorEncoder[left] = 0;



		while(nMotorEncoder[left] < encoderCounts)
		{
			int sonarValue = SensorValue[sonarFront] - SensorValue[sonarBack];//used to correct for alignment with wall
			float avgDist =  (SensorValue[sonarFront] + SensorValue[sonarBack])/2;//used to correct for distance from the wall
			previousP = p;
			p = sonarValue - wallDistance;
			i += p;
			d = p- previousP;//derivative disregards time (dt) as it should be time between loops should be constant - it will be compensated for in kd)

			previousAvgDistP = avgDistP;
			avgDistP = avgDist - wallDistance;
			avgDistI += avgDistP;
			avgDistD = avgDistP - previousAvgDistP;



			correction = (int)round((kp*p + ki * i + kd*d)+(avgDistkp*avgDistP + avgDistki * avgDistI + avgDistkd*avgDistD));

			//if sonarDiff > 0, sonarFront is farther away, meaning the robot is skewed left, there for add power to the left motor and subtract from
			//therefore a positive correciton should be added to the left motor power and subtracted from right motor power to turn the robot closer to the wall
			//and vice versa for sonarDiff < 0
			int newLeft = leftPow + correction;
			int newRight = rightPow - correction;

			if(newLeft < 20)
				newLeft = 20;
			if(newRight < 20)
				newRight =20;

		if(newLeft > 80)
				newLeft = 80;
			if(newRight > 80)
				newRight =80;



			motor[left] = (newLeft*1.3);
			motor[right] = newRight;

			print(newLeft,2);
			print(newRight,4);
			print(sonarValue, 6);

			print(p,8);
			wait10Msec(10);
			}
}

//Only maintains alignment
void wallFollowDrive2(float inches, int leftPow, int rightPow)
{
		/*
		the correction is calculated by the formula:
		C = P + I + D
		P = error * kp
		I = I * ki (I = integral sum of all errors)
		D = D * kd (where D = the derivative of the error d/dt(e))
		*/

		//constants that vary the effect of the P, I, and D terms
		//TODO: tune values
		float kp = 2.0;//propotional constant
		float ki = 0.1;//integral constant
		float kd = 1;//derivative constant

		//declare variables used in PID
		int i = 0;//integral sum
		float p;//error used to calcualate PID correction
		int d;//derivative of error (p)
		int previousP = 0;//previous error used to calculate derivative
		int correction = 0;

		int encoderCounts = inchesToEncoder(inches);
		nMotorEncoder[left] = 0;

		while(nMotorEncoder[left] < encoderCounts)
		{
			int sonarDiff = SensorValue[sonarFront] - SensorValue[sonarBack];
			p = sonarDiff;
			i += p;
			d = p- previousP;//derivative disregards time (dt) as it should be time between loops should be constant - it will be compensated for in kd)
			correction = (int)round(kp*p + ki * i + kd*d);

			//if sonarDiff > 0, sonarFront is farther away, meaning the robot is skewed left, there for add power to the left motor and subtract from
			//therefore a positive correciton should be added to the left motor power and subtracted from right motor power to turn the robot closer to the wall
			//and vice versa for sonarDiff < 0
			int newLeft = leftPow + correction;
			int newRight = rightPow - correction;

			if(newLeft < 20)
				newLeft = 20;
			if(newRight < 20)
				newRight =20;

		if(newLeft > 80)
				newLeft = 80;
			if(newRight > 80)
				newRight =80;



			motor[left] = (newLeft*1.3);
			motor[right] = newRight;

			print(newLeft,2);
			print(newRight,4);
			print(sonarDiff, 6);

			print(p,8);
			wait10Msec(10);
			}
}

task main()

{
/*
while(true)
	{
		print(SensorValue[sonar], 4);
	}
*/



driveInches(16,30,20);
wait1Msec(500);
int sonarValue = SensorValue[sonarFront];
wait1Msec(500);
wallFollowDrive2(84,30,30);
}
