#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     combine,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     left1,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     left2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     right1,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     right2,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servoR2,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servoR1,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servoL1,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servoL2,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*IR Floor Code (3565)
Lilia Heinold, Alex McKinley7
Version info in GitHub tags/releases.
1-8-14: New motor configs for base rewire
*/

#include "Standard_Drive.c";
#include "JoystickDriver.c";
#include "nxtIO.c";

bool inputWaitForStart();
int inputWaitSecs();

/*
Start splitting center goal
Drive forward 30in
Check IR
	If IR is present - Position 1
	If Not
		Turn Right 45
		Drive forward 12sqrt(2)
		Turn Left 90
		Check IR
			If IR is present - Position 2
			If Not (Position 3)
				Turn right 45
				Forward 36 in
				Left 90
				Forward 48
*/

task main()
{
	eraseDisplay();
	bool i = inputWaitForStart();//check for wait for start
	wait1Msec(500);

	int waitSecs = inputWaitSecs();//Input wait seconds from display

	if(i)
	{
		waitForStart();
	}

	wait1Msec(waitSecs*1000);	//Wait based on the selected value

	driveInches(30,50,50); //Drive to first position
	//Check IR
	print(SensorValue[ir]);
	wait1Msec(500);
	if(SensorValue[ir] >= 4 && SensorValue[ir] <= 6){ //Position 1
		//Knock over the pole in position 1
		turn(RIGHT,90);
		driveInches(12,50,50);
		turn(LEFT,90);
		driveInches(48,100,100);
		driveInches(-20,100,100);
		driveInches(20,100,100);
	}
	else{ //If it is in position 2 or 3
		//Drive to position 2
		driveInches(-15,50,50);
		turn(LEFT,45);
		driveInches(25);
		turn(RIGHT,100);
		//Check ir
		print(SensorValue[ir]);
		wait1Msec(500);
		if(SensorValue[ir] >= 4 && SensorValue[ir] <= 6){ //Position 2
			//Drive to position 2 and knock over pole
			driveInches(-6,50,50);
			turn(RIGHT,45);
			driveInches(15,50,50);
			turn(LEFT,40);
			driveInches(48,100,100);
			driveInches(-20,100,100);
			driveInches(20,100,100);
		}
		else
		{ //Position 3
			//Drive to position 3 and kock over pole
			turn(RIGHT,55);
			driveInches(36,100,100);
			driveInches(10,100,30);
			driveInches(-20,100,100);
			driveInches(20,100,100);
		}
	}


}

bool inputWaitForStart() {
	bool select = true;
	eraseDisplay();
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		if(select)
			print(a, 2);
		else
			print(b, 2);
	}
	PlaySound(soundBlip);
	return select;
}

int inputWaitSecs() {
	int waitSecs = 0;
	eraseDisplay();
	print(waitSecs,2);
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			waitSecs++;
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs,2);
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			if(waitSecs > 0)
			{
				waitSecs--;
			}
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs,2);
			wait1Msec(500);
		}
	}
	PlaySound(soundBlip);
	return waitSecs;
}
