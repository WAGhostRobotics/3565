#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     asf,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    jack1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    jack2,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*IR Floor Code (3565)
Lilia Heinold, Alex McKinley
0.02 11/18 Added basic code/algoritm
0.1 11/19 Fixed code
--- 11/25 Added documentation
*/

#include "Standard_Drive.c";
#include "JoystickDriver.c";

bool inputWaitForStart();
int inputWaitSecs();

/*
Start splitting center goal
Drive forward 30in
Check IR
	If IR is present - Position 1
	If Not
		Turn Right 45
		Drive forward 12sqrt(2)
		Turn Left 90
		Check IR
			If IR is present - Position 2
			If Not (Position 3)
				Turn right 45
				Forward 36 in
				Left 90
				Forward 48
*/

task main()
{
	eraseDisplay();
	bool i = inputWaitForStart();//check for wait for start
	wait1Msec(500);

	int waitSecs = inputWaitSecs();//Input wait seconds from display

	if(i)
	{
		waitForStart();
	}

	wait1Msec(waitSecs*1000);	//Wait based on the selected value

	driveInches(30,50,50); //Drive to first position
	//Check IR
	print(SensorValue[ir]);
	wait1Msec(500);
	if(SensorValue[ir] >= 4 && SensorValue[ir] <= 6){ //Position 1
		//Knock over the pole in position 1
		turn(RIGHT,90);
		driveInches(12,50,50);
		turn(LEFT,90);
		driveInches(48,100,100);
		driveInches(-20,100,100);
		driveInches(20,100,100);
	}
	else{ //If it is in position 2 or 3
		//Drive to position 2
		driveInches(-15,50,50);
		turn(LEFT,45);
		driveInches(25);
		turn(RIGHT,100);
		//Check ir
		print(SensorValue[ir]);
		wait1Msec(500);
		if(SensorValue[ir] >= 4 && SensorValue[ir] <= 6){ //Position 2
			//Drive to position 2 and knock over pole
			driveInches(-6,50,50);
			turn(RIGHT,45);
			driveInches(15,50,50);
			turn(LEFT,40);
			driveInches(48,100,100);
			driveInches(-20,100,100);
			driveInches(20,100,100);
		}
		else{ //Position 3
			//Drive to position 3 and kock over pole
			turn(RIGHT,55);
			driveInches(36,100,100);
			driveInches(10,100,30);
			driveInches(-20,100,100);
			driveInches(20,100,100);
		}
	}


}

bool inputWaitForStart() {
	bool select = true;
	eraseDisplay();
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			select = !select;
			PlaySound(soundBlip);
			eraseDisplay();
			wait1Msec(500);
		}
		if(select)
			print(a, 2);
		else
			print(b, 2);
	}
	PlaySound(soundBlip);
	return select;
}

int inputWaitSecs() {
	int waitSecs = 0;
	eraseDisplay();
	print(waitSecs,2);
	while(nNxtButtonPressed != 3) {
		if(nNxtButtonPressed == 1) { //Right arrow
			waitSecs++;
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs,2);
			wait1Msec(500);
		}
		else if(nNxtButtonPressed == 2) {
			if(waitSecs > 0)
			{
				waitSecs--;
			}
			PlaySound(soundBlip);
			eraseDisplay();
			print(waitSecs,2);
			wait1Msec(500);
		}
	}
	PlaySound(soundBlip);
	return waitSecs;
}
